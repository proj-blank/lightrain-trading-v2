# daily_trading.py
"""
Daily automated trading script with Telegram notifications (PostgreSQL version).
Run this once per day (before market open or after close).
"""

import os
import sys
import pandas as pd
from datetime import datetime

# Add LightRain path for db_connection
sys.path.insert(0, '/home/ubuntu/trading')

# Database imports
from scripts.db_connection import (
    get_active_positions, add_position, close_position, log_trade,
    get_capital, update_capital, get_available_cash,
    is_position_on_hold, add_circuit_breaker_hold, get_today_trades
)

# Trading logic imports
from scripts.data_loader_angelone import load_data_angelone as load_data
from scripts.signal_generator_daily import generate_signal_daily
from scripts.signal_generator_v3 import get_enabled_indicators
from scripts.risk_manager import (
    calculate_position_metrics, check_circuit_breaker, analyze_drop_reason,
    format_circuit_breaker_message
)
from scripts.telegram_bot import (
    send_daily_report, send_trade_alert, send_stop_loss_alert,
    send_take_profit_alert, format_portfolio_summary,
    format_trades_today, format_signals, send_telegram_message
)
from scripts.rs_rating import RelativeStrengthAnalyzer

# Optional AI analyzer (if available)
try:
    from scripts.ai_analyzer import analyze_position_with_ai
    AI_ANALYSIS_AVAILABLE = True
except ImportError:
    AI_ANALYSIS_AVAILABLE = False
    def analyze_position_with_ai(*args, **kwargs):
        return None

# Configuration
ACCOUNT_SIZE = 500000
MAX_POSITIONS = 10
MAX_POSITION_PCT = 0.20
MIN_COMBINED_SCORE = 50
USE_ATR_SIZING = True
MIN_RS_RATING = 60  # NEW: Minimum Relative Strength rating for daily trading (1-99 scale)
STRATEGY = 'DAILY'

print("=" * 70)
print("ü§ñ DAILY AUTOMATED TRADING (PostgreSQL)")
print("=" * 70)
print(f"üìÖ {datetime.now().strftime('%d %b %Y, %H:%M:%S')}")
print("=" * 70)

# Check if trading is enabled
TRADING_ENABLED = os.getenv("TRADING_ENABLED", "true").lower() == "true"

if not TRADING_ENABLED:
    message = "‚è∏Ô∏è Trading is PAUSED\n\nTo resume, set TRADING_ENABLED=true in .env"
    print(message)
    send_telegram_message(message)
    sys.exit(0)

# Load stock data
print("\nüì• Loading stock data...")
stock_data = load_data(period="6mo", interval="1d")

if not stock_data:
    error_msg = "‚ùå No stock data loaded. Check watchlist."
    print(error_msg)
    send_telegram_message(error_msg)
    sys.exit(1)

print(f"‚úÖ Loaded {len(stock_data)} stocks")

# Load portfolio from database
print("üì• Loading portfolio from database...")
positions = get_active_positions(STRATEGY)

# Convert to DataFrame format for compatibility with existing code
portfolio_data = []
for pos in positions:
    portfolio_data.append({
        'Ticker': pos['ticker'],
        'Status': pos['status'],
        'EntryPrice': float(pos['entry_price']),
        'EntryDate': pos['entry_date'].strftime('%Y-%m-%d') if hasattr(pos['entry_date'], 'strftime') else str(pos['entry_date']),
        'Quantity': int(pos['quantity']),
        'StopLoss': float(pos['stop_loss']),
        'TakeProfit': float(pos['take_profit'])
    })

if portfolio_data:
    portfolio = pd.DataFrame(portfolio_data)
    print(f"‚úÖ Portfolio loaded: {len(portfolio[portfolio['Status']=='HOLD'])} positions")
else:
    portfolio = pd.DataFrame(columns=["Ticker", "Status", "EntryPrice", "EntryDate", "Quantity", "StopLoss", "TakeProfit"])
    print("‚ö†Ô∏è No positions in database")

# Track today's activity
signals_generated = []
trades_today = []

print(f"\nüéØ Analyzing {len(stock_data)} stocks...")

# Show which indicators are enabled
enabled = get_enabled_indicators()
print(f"üìä Using indicators: {', '.join(enabled)}")
print()

# Initialize RS Analyzer
rs_analyzer = RelativeStrengthAnalyzer()
rs_filtered_count = 0

# Helper function to update portfolio with database sync
def update_portfolio_with_db(portfolio, ticker, signal, df, account_size, use_atr_sizing, max_positions, max_position_pct):
    """Update portfolio and sync with database"""
    from scripts.portfolio_manager import update_portfolio

    # Store original portfolio state
    positions_before = len(portfolio[portfolio['Status'] == 'HOLD'])

    # Update using existing logic
    portfolio = update_portfolio(
        portfolio, ticker, signal, df=df,
        account_size=account_size,
        use_atr_sizing=use_atr_sizing,
        max_positions=max_positions,
        max_position_pct=max_position_pct
    )

    positions_after = len(portfolio[portfolio['Status'] == 'HOLD'])

    # Sync with database
    if signal == "BUY" and positions_after > positions_before:
        # New position added
        pos = portfolio[portfolio['Ticker'] == ticker].iloc[0]
        try:
            add_position(
                ticker=ticker,
                strategy=STRATEGY,
                entry_price=float(pos['EntryPrice']),
                quantity=int(pos['Quantity']),
                stop_loss=float(pos['StopLoss']),
                take_profit=float(pos['TakeProfit']),
                category='Unknown',  # Can enhance with category detection
                entry_date=pos.get('EntryDate', datetime.now().strftime('%Y-%m-%d'))
            )

            # Log trade
            log_trade(
                ticker=ticker,
                strategy=STRATEGY,
                signal='BUY',
                price=float(pos['EntryPrice']),
                quantity=int(pos['Quantity']),
                pnl=0,
                notes=f"Signal score: {MIN_COMBINED_SCORE}"
            )
        except Exception as e:
            print(f"‚ö†Ô∏è Failed to add position to database: {e}")

    elif signal == "SELL" and positions_after < positions_before:
        # Position closed
        if ticker in portfolio['Ticker'].values:
            pos = portfolio[portfolio['Ticker'] == ticker].iloc[0]
            entry_price = float(pos['EntryPrice'])
            current_price = float(df['Close'].iloc[-1])
            qty = int(pos['Quantity'])
            pnl = (current_price - entry_price) * qty

            try:
                close_position(ticker, STRATEGY, current_price, pnl)
                update_capital(STRATEGY, pnl)

                # Log trade
                log_trade(
                    ticker=ticker,
                    strategy=STRATEGY,
                    signal='SELL',
                    price=current_price,
                    quantity=qty,
                    pnl=pnl,
                    notes=f"Exit signal"
                )
            except Exception as e:
                print(f"‚ö†Ô∏è Failed to close position in database: {e}")

    return portfolio

# Process each stock
for ticker, df in stock_data.items():
    if df.empty or len(df) < 60:
        continue

    try:
        # NEW: RS Rating Filter (Pre-filter before expensive indicator calculations)
        rs_rating = rs_analyzer.calculate_rs_rating(ticker)
        if rs_rating < MIN_RS_RATING:
            rs_filtered_count += 1
            continue  # Skip weak stocks

        # Generate signal using v3 (configurable) - only for stocks that passed RS filter
        signal, score, details = generate_signal_daily(df, min_score=MIN_COMBINED_SCORE)

        # Track signal
        if signal != "HOLD":
            signals_generated.append({
                'ticker': ticker,
                'action': signal,
                'score': score,
                'details': details,
                'rs_rating': rs_rating  # Store RS rating for reference
            })
            print(f"{ticker}: {signal} (Score: {score} | RS: {rs_rating})")

        # Track portfolio before update
        positions_before = len(portfolio[portfolio['Status'] == 'HOLD'])

        # Update portfolio with database sync
        portfolio = update_portfolio_with_db(
            portfolio, ticker, signal, df=df,
            account_size=ACCOUNT_SIZE,
            use_atr_sizing=USE_ATR_SIZING,
            max_positions=MAX_POSITIONS,
            max_position_pct=MAX_POSITION_PCT
        )

        # Track if trade happened
        positions_after = len(portfolio[portfolio['Status'] == 'HOLD'])

        if positions_before != positions_after or signal != "HOLD":
            # Check recent trades from database
            today_db_trades = get_today_trades(STRATEGY)

            for trade in today_db_trades:
                if trade['ticker'] == ticker:
                    # Send Telegram alert
                    price = float(trade['price'])
                    qty = int(trade['quantity'])
                    action = trade['signal']
                    notes = trade.get('notes', '')

                    # Determine alert type
                    if 'Stop-loss' in str(notes) or action == 'SELL':
                        pnl = float(trade.get('pnl', 0))
                        entry_price = float(portfolio[portfolio['Ticker']==ticker]['EntryPrice'].iloc[0]) if ticker in portfolio['Ticker'].values else 0
                        if 'Stop-loss' in str(notes):
                            send_stop_loss_alert(ticker, entry_price, price, pnl, strategy=STRATEGY)
                        elif 'Take-profit' in str(notes):
                            send_take_profit_alert(ticker, entry_price, price, pnl, strategy=STRATEGY)
                    elif action == 'BUY':
                        details_str = f"{notes}" if notes else ""
                        send_trade_alert(ticker, action, price, qty, details_str, strategy=STRATEGY)

    except Exception as e:
        print(f"‚ö†Ô∏è Error processing {ticker}: {e}")
        continue

print(f"\n‚úÖ Portfolio processing complete")

# Update positions tracker (for dynamic watchlist)
from scripts.position_tracker import update_positions_file
num_positions = len(portfolio[portfolio['Status'] == 'HOLD'])
print(f"‚úÖ Active positions: {num_positions}")

# Update performance metrics
from scripts.performance_tracker import update_results
update_results(portfolio, stock_data)

# Circuit Breaker Monitoring (4% alert / 5% hard stop)
print("\nüõ°Ô∏è Checking circuit breakers...")

for _, row in portfolio[portfolio['Status'] == 'HOLD'].iterrows():
    ticker = row['Ticker']
    entry_price = float(row['EntryPrice'])
    entry_date = row.get('EntryDate', datetime.now().strftime("%Y-%m-%d"))
    qty = int(row['Quantity'])

    # Skip if on hold (check database)
    if is_position_on_hold(ticker, STRATEGY):
        print(f"  ‚è∏Ô∏è {ticker}: On hold (suppressed)")
        continue

    if ticker in stock_data and not stock_data[ticker].empty:
        current_price = float(stock_data[ticker]['Close'].iloc[-1])

        # Check circuit breaker (4% alert, 5% hard stop)
        action, loss, analysis = check_circuit_breaker(
            ticker, entry_price, current_price, entry_date,
            alert_threshold=0.04,  # 4% alert
            hard_stop=0.05  # 5% hard stop
        )

        if action == 'CIRCUIT_BREAKER':
            # Hard stop - immediate exit
            print(f"  üî¥ CIRCUIT BREAKER: {ticker} | Loss: {analysis['loss_pct']:.2f}%")

            # Format and send message
            msg = format_circuit_breaker_message(ticker, analysis)
            send_telegram_message(msg)

            # Execute exit in database
            pnl = (current_price - entry_price) * qty
            try:
                close_position(ticker, STRATEGY, current_price, pnl)
                update_capital(STRATEGY, pnl)

                log_trade(
                    ticker=ticker,
                    strategy=STRATEGY,
                    signal='SELL',
                    price=current_price,
                    quantity=qty,
                    pnl=pnl,
                    notes=f"Circuit breaker at {analysis['loss_pct']:.2f}%"
                )
            except Exception as e:
                print(f"  ‚ùå Failed to exit position: {e}")

            # Update local portfolio
            portfolio.loc[portfolio['Ticker'] == ticker, 'Status'] = 'SOLD'

            print(f"  ‚úÖ Position exited: {ticker}")

        elif action == 'ALERT':
            # 4% alert - investigate
            print(f"  ‚ö†Ô∏è ALERT: {ticker} | Loss: {analysis['loss_pct']:.2f}%")

            # Analyze drop reason
            drop_analysis = analyze_drop_reason(ticker)

            # Get AI analysis
            ai_analysis = None
            try:
                ai_analysis = analyze_position_with_ai(
                    ticker, entry_price, current_price, entry_date
                )
            except Exception as e:
                print(f"    ‚ö†Ô∏è AI analysis failed: {e}")

            # Format alert message
            from scripts.risk_manager import format_alert_message
            msg = format_alert_message(ticker, analysis, drop_analysis, ai_analysis)
            send_telegram_message(msg)

print("‚úÖ Circuit breaker check complete\n")

# Calculate portfolio metrics
metrics = calculate_position_metrics(portfolio, stock_data)

# Get today's trades from database
today_trades_list = get_today_trades(STRATEGY)
today_trades_df = pd.DataFrame(today_trades_list) if today_trades_list else pd.DataFrame()

# Format and send daily report
portfolio_summary = format_portfolio_summary(metrics)
trades_summary = format_trades_today(today_trades_df)
signals_summary = format_signals(signals_generated)

send_daily_report(portfolio_summary, trades_summary, signals_summary, strategy=STRATEGY)

# Print summary
print(f"\n{'='*70}")
print("üìä DAILY SUMMARY")
print(f"{'='*70}")
print(f"Signals Generated: {len(signals_generated)}")
print(f"Stocks Filtered by RS < {MIN_RS_RATING}: {rs_filtered_count}")
print(f"Trades Executed: {len(today_trades_df)}")
print(f"Active Positions: {metrics['total_positions']}")
print(f"Portfolio P&L: ‚Çπ{metrics['total_unrealized_pnl']:,.2f}")
print(f"{'='*70}")
print("‚úÖ Daily trading complete!")
print(f"{'='*70}\n")
