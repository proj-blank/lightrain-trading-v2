#!/usr/bin/env python3
"""
Smart Portfolio Allocation - Option B: Risk-Based Variable Position Sizing

Allocates capital across Large/Mid/Micro caps:
- Target Capital: 60% Large / 20% Mid / 20% Micro
- Position Sizing: Variable based on risk/volatility
  * Large-caps: Lower volatility → Larger position sizes
  * Mid-caps: Medium volatility → Medium position sizes
  * Micro-caps: Higher volatility → Smaller position sizes
"""

import numpy as np


def calculate_category_risk(candidates, category_key):
    """
    Calculate average volatility/risk for a market cap category.

    Args:
        candidates: List of candidate stocks with 'atr_pct' or 'volatility' field
        category_key: 'large_caps', 'mid_caps', or 'micro_caps'

    Returns:
        avg_risk: Average risk metric (ATR% or volatility)
    """
    if not candidates:
        return 0.0

    # Try to get ATR% or volatility from candidates
    risk_values = []
    for candidate in candidates:
        risk = candidate.get('atr_pct') or candidate.get('volatility') or candidate.get('risk', 0)
        if risk > 0:
            risk_values.append(risk)

    if not risk_values:
        # Default risk assumptions if no data
        defaults = {
            'large_caps': 2.0,   # 2% daily volatility
            'mid_caps': 3.5,     # 3.5% daily volatility
            'micro_caps': 5.0    # 5% daily volatility
        }
        return defaults.get(category_key, 3.0)

    return np.mean(risk_values)


def calculate_smart_allocation(
    candidates,  # Dict: {'large_caps': [...], 'mid_caps': [...], 'micro_caps': [...]
    total_capital,
    max_positions=10,
    target_allocation={'large': 0.60, 'mid': 0.20, 'micro': 0.20},
    risk_factor=1.0  # Multiplier for position sizing (higher = more aggressive)
):
    """
    Calculate smart allocation with risk-based position sizing (Option B).

    Args:
        candidates: Dict of scored candidates by category (each with risk metrics)
        total_capital: Total capital to deploy
        max_positions: Maximum number of positions (soft limit)
        target_allocation: Target capital % for each category
        risk_factor: Position sizing aggressiveness (1.0 = standard, >1 = larger positions)

    Returns:
        allocation_plan: Dict with positions per category and capital per position
    """

    # Count available candidates
    available = {
        'large': len(candidates.get('large_caps', [])),
        'mid': len(candidates.get('mid_caps', [])),
        'micro': len(candidates.get('micro_caps', []))
    }

    print()
    print("=" * 80)
    print("SMART ALLOCATION CALCULATOR (OPTION B: RISK-BASED)")
    print("=" * 80)
    print(f"Total Capital: ₹{total_capital:,.0f}")
    print(f"Target Allocation: {int(target_allocation['large']*100)}% Large / {int(target_allocation['mid']*100)}% Mid / {int(target_allocation['micro']*100)}% Micro")
    print()

    print("Available Candidates:")
    print(f"  Large-caps: {available['large']}")
    print(f"  Mid-caps:   {available['mid']}")
    print(f"  Micro-caps: {available['micro']}")
    print()

    # Calculate capital allocation per category (60/20/20)
    capital_allocation = {
        'large': total_capital * target_allocation['large'],
        'mid': total_capital * target_allocation['mid'],
        'micro': total_capital * target_allocation['micro']
    }

    print("Capital Allocation:")
    print(f"  Large-caps: ₹{capital_allocation['large']:,.0f} ({target_allocation['large']*100:.0f}%)")
    print(f"  Mid-caps:   ₹{capital_allocation['mid']:,.0f} ({target_allocation['mid']*100:.0f}%)")
    print(f"  Micro-caps: ₹{capital_allocation['micro']:,.0f} ({target_allocation['micro']*100:.0f}%)")
    print()

    # Calculate average risk per category
    risk_metrics = {
        'large': calculate_category_risk(candidates.get('large_caps', []), 'large_caps'),
        'mid': calculate_category_risk(candidates.get('mid_caps', []), 'mid_caps'),
        'micro': calculate_category_risk(candidates.get('micro_caps', []), 'micro_caps')
    }

    print("Risk Metrics (Volatility %):")
    print(f"  Large-caps: {risk_metrics['large']:.2f}%")
    print(f"  Mid-caps:   {risk_metrics['mid']:.2f}%")
    print(f"  Micro-caps: {risk_metrics['micro']:.2f}%")
    print()

    # Calculate position size based on inverse risk
    # Position size = (Base Amount) / (Risk Factor)
    # Lower risk = Larger positions, Higher risk = Smaller positions

    # Use average risk as baseline
    avg_risk = np.mean(list(risk_metrics.values()))

    # Calculate position sizes (inversely proportional to risk)
    position_sizes = {}
    for category in ['large', 'mid', 'micro']:
        risk = risk_metrics[category]
        if risk > 0:
            # Inverse relationship: lower risk = larger size
            # Normalize by average risk to maintain reasonable sizing
            position_sizes[category] = (avg_risk / risk) * (total_capital / max_positions) * risk_factor
        else:
            position_sizes[category] = total_capital / max_positions

    print("Position Sizes (Risk-Adjusted):")
    print(f"  Large-caps: ₹{position_sizes['large']:,.0f} per position")
    print(f"  Mid-caps:   ₹{position_sizes['mid']:,.0f} per position")
    print(f"  Micro-caps: ₹{position_sizes['micro']:,.0f} per position")
    print()

    # Calculate number of positions from allocated capital and position size
    num_positions = {}
    for category in ['large', 'mid', 'micro']:
        if position_sizes[category] > 0:
            # Number of positions = Capital / Position Size
            positions = int(capital_allocation[category] / position_sizes[category])
            # Ensure at least 1 position if capital is allocated and candidates exist
            if positions == 0 and capital_allocation[category] > 0 and available[category] > 0:
                positions = 1
            # Cap by available candidates
            positions = min(positions, available[category])
            num_positions[category] = positions
        else:
            num_positions[category] = 0

    print("Calculated Positions:")
    print(f"  Large-caps: {num_positions['large']} positions")
    print(f"  Mid-caps:   {num_positions['mid']} positions")
    print(f"  Micro-caps: {num_positions['micro']} positions")
    print(f"  Total:      {sum(num_positions.values())} positions")
    print()

    # Recalculate actual capital per position based on final allocation
    capital_per_position = {}
    actual_capital_used = {}

    for category in ['large', 'mid', 'micro']:
        if num_positions[category] > 0:
            # Divide allocated capital evenly among positions
            capital_per_position[category] = capital_allocation[category] / num_positions[category]
            actual_capital_used[category] = capital_allocation[category]
        else:
            capital_per_position[category] = 0
            actual_capital_used[category] = 0

    # Redistribute unused capital if any category has 0 positions
    unused_capital = sum(
        capital_allocation[cat] - actual_capital_used[cat]
        for cat in ['large', 'mid', 'micro']
    )

    if unused_capital > 0:
        print(f"⚠️  Unused Capital: ₹{unused_capital:,.0f}")
        print("   Redistributing to available categories...")

        # Redistribute proportionally to categories with positions
        categories_with_positions = [cat for cat in ['large', 'mid', 'micro'] if num_positions[cat] > 0]

        if categories_with_positions:
            extra_per_category = unused_capital / len(categories_with_positions)
            for cat in categories_with_positions:
                actual_capital_used[cat] += extra_per_category
                capital_per_position[cat] = actual_capital_used[cat] / num_positions[cat]
                print(f"   +₹{extra_per_category:,.0f} to {cat}")
        print()

    print("Final Allocation:")
    print(f"  Large-caps: {num_positions['large']} positions × ₹{capital_per_position['large']:,.0f} = ₹{actual_capital_used['large']:,.0f}")
    print(f"  Mid-caps:   {num_positions['mid']} positions × ₹{capital_per_position['mid']:,.0f} = ₹{actual_capital_used['mid']:,.0f}")
    print(f"  Micro-caps: {num_positions['micro']} positions × ₹{capital_per_position['micro']:,.0f} = ₹{actual_capital_used['micro']:,.0f}")
    print()

    total_allocated = sum(actual_capital_used.values())
    print(f"Total Allocated: ₹{total_allocated:,.0f} ({total_allocated/total_capital*100:.1f}%)")
    print(f"Total Positions: {sum(num_positions.values())}")
    print("=" * 80)

    return {
        'positions': num_positions,
        'capital': actual_capital_used,
        'capital_per_position': capital_per_position,
        'total_positions': sum(num_positions.values()),
        'position_sizes': position_sizes,
        'risk_metrics': risk_metrics
    }


def select_positions(candidates, allocation_plan):
    """
    Select actual positions based on allocation plan.

    Args:
        candidates: Dict of lists, each item has 'ticker' and 'score'
        allocation_plan: Output from calculate_smart_allocation()

    Returns:
        selected: List of selected positions with allocation
    """
    selected = []

    for category in ['large_caps', 'mid_caps', 'micro_caps']:
        category_short = category.split('_')[0]  # 'large', 'mid', 'micro'

        num_positions = allocation_plan['positions'][category_short]
        capital_per_pos = allocation_plan['capital_per_position'][category_short]

        if num_positions == 0:
            continue

        # Get top N candidates by score
        category_candidates = candidates.get(category, [])

        # Sort by score descending
        sorted_candidates = sorted(category_candidates, key=lambda x: x.get('score', 0), reverse=True)

        # Take top N
        for candidate in sorted_candidates[:num_positions]:
            selected.append({
                'ticker': candidate['ticker'],
                'category': category_short.capitalize() + '-cap',
                'score': candidate.get('score', 0),
                'allocated_capital': capital_per_pos
            })

    return selected


if __name__ == "__main__":
    # Test the allocation logic with risk metrics
    test_candidates = {
        'large_caps': [
            {'ticker': f'LARGE{i}.NS', 'score': 70+i, 'atr_pct': 1.8 + i*0.1}
            for i in range(10)
        ],
        'mid_caps': [
            {'ticker': f'MID{i}.NS', 'score': 65+i, 'atr_pct': 3.2 + i*0.1}
            for i in range(5)
        ],
        'micro_caps': [
            {'ticker': f'MICRO{i}.NS', 'score': 60+i, 'atr_pct': 4.5 + i*0.2}
            for i in range(2)
        ]
    }

    plan = calculate_smart_allocation(
        test_candidates,
        total_capital=1000000,
        max_positions=10
    )

    print()
    print("=" * 80)
    print("SELECTED POSITIONS")
    print("=" * 80)

    selected = select_positions(test_candidates, plan)

    for pos in selected:
        print(f"{pos['ticker']:15s} | {pos['category']:10s} | Score: {pos['score']:3d} | ₹{pos['allocated_capital']:,.0f}")

    print()
    print(f"Total Positions: {len(selected)}")
    print(f"Total Capital: ₹{sum(p['allocated_capital'] for p in selected):,.0f}")
