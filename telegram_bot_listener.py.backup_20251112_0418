#!/usr/bin/env python3
"""
Telegram Bot Command Listener for LightRain
Responds to user commands: /help, /status, /positions, /summary
"""
import os
import sys
sys.path.insert(0, '/home/ubuntu/trading')

import requests
import time
from datetime import datetime
from dotenv import load_dotenv
from scripts.db_connection import (
    get_active_positions, get_capital, get_available_cash,
    close_position, log_trade, update_capital, is_position_on_hold,
    add_circuit_breaker_hold
)

load_dotenv('/home/ubuntu/trading/.env')

# Import yfinance for live price fetching
try:
    import yfinance as yf
    YFINANCE_AVAILABLE = True
except ImportError:
    YFINANCE_AVAILABLE = False

TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
CHAT_ID = os.getenv('TELEGRAM_CHAT_ID')
BASE_URL = f'https://api.telegram.org/bot{TOKEN}'

def send_message(text):
    requests.post(f'{BASE_URL}/sendMessage', json={'chat_id': CHAT_ID, 'text': text, 'parse_mode': 'HTML'})

def get_updates(offset=None):
    url = f'{BASE_URL}/getUpdates'
    params = {'timeout': 30, 'offset': offset} if offset else {'timeout': 30}
    try:
        response = requests.get(url, params=params, timeout=35)
        return response.json()
    except:
        return {'ok': False}

def handle_help():
    return """<b>ü§ñ LightRain Bot Commands</b>

<b>Portfolio & Status:</b>
/help - Show this help
/status - System status
/positions - Active positions (with P&L)
/pnl - Portfolio P&L summary
/daily - DAILY strategy positions
/swing - SWING strategy positions
/capital - Capital tracker

<b>Circuit Breaker Control:</b>
/hold TICKER - Continue holding despite alert
/exit TICKER - Force exit position now
/smart-stop TICKER - Use smart stops (ATR/Chandelier)
"""

def handle_status():
    try:
        daily_pos = len(get_active_positions('DAILY'))
        swing_pos = len(get_active_positions('SWING'))
        return f"""<b>üìä System Status</b>

Active Positions:
  DAILY: {daily_pos} positions
  SWING: {swing_pos} positions

Time: {datetime.now().strftime('%H:%M:%S IST')}
Status: ‚úÖ Running
"""
    except Exception as e:
        return f"‚ùå Error: {e}"

def handle_positions(strategy=None):
    try:
        strategies = [strategy] if strategy else ['DAILY', 'SWING']
        result = "<b>üìà Active Positions</b>\n\n"

        for strat in strategies:
            positions = get_active_positions(strat)
            cash = get_available_cash(strat)
            result += f"<b>{strat}</b> ({len(positions)} positions)\n"
            result += f"Cash: ‚Çπ{float(cash):,.0f}\n\n"

            total_pnl = 0
            for p in positions:
                ticker = p['ticker']
                entry_price = float(p['entry_price'])
                qty = int(p['quantity'])

                # Fetch current price
                current_price = entry_price
                if YFINANCE_AVAILABLE:
                    try:
                        stock = yf.Ticker(ticker)
                        hist = stock.history(period='1d')
                        if not hist.empty:
                            current_price = float(hist['Close'].iloc[-1])
                    except:
                        pass

                # Calculate P&L
                pnl = (current_price - entry_price) * qty
                pnl_pct = ((current_price - entry_price) / entry_price) * 100
                total_pnl += pnl

                emoji = "üü¢" if pnl >= 0 else "üî¥"
                result += f"  {emoji} {ticker}: {qty} @ ‚Çπ{entry_price:.2f}\n"
                result += f"     Now: ‚Çπ{current_price:.2f} | P&L: ‚Çπ{pnl:,.0f} ({pnl_pct:+.1f}%)\n"

            if len(positions) > 0:
                result += f"\n  üí∞ Total P&L: ‚Çπ{total_pnl:,.0f}\n"
            result += "\n"

        return result
    except Exception as e:
        return f"‚ùå Error: {e}"

def handle_capital():
    try:
        result = "<b>üí∞ Capital Tracker</b>\n\n"
        for strategy in ['DAILY', 'SWING']:
            cap = get_capital(strategy)
            result += f"<b>{strategy}</b>\n"
            result += f"  Trading: ‚Çπ{float(cap['current_trading_capital']):,.0f}\n"
            result += f"  Profits: ‚Çπ{float(cap['total_profits_locked']):,.0f}\n"
            result += f"  Losses: ‚Çπ{float(cap['total_losses']):,.0f}\n\n"
        return result
    except Exception as e:
        return f"‚ùå Error: {e}"

def handle_pnl():
    """Dedicated P&L summary report"""
    try:
        result = "<b>üí∞ Portfolio P&L Summary</b>\n"
        result += f"‚è∞ {datetime.now().strftime('%H:%M:%S IST')}\n\n"

        grand_total_pnl = 0

        for strategy in ['DAILY', 'SWING']:
            positions = get_active_positions(strategy)
            result += f"<b>{strategy}</b> ({len(positions)} positions)\n"

            strategy_pnl = 0
            for p in positions:
                ticker = p['ticker']
                entry_price = float(p['entry_price'])
                qty = int(p['quantity'])

                # Fetch current price
                current_price = entry_price
                if YFINANCE_AVAILABLE:
                    try:
                        stock = yf.Ticker(ticker)
                        hist = stock.history(period='1d')
                        if not hist.empty:
                            current_price = float(hist['Close'].iloc[-1])
                    except:
                        pass

                pnl = (current_price - entry_price) * qty
                pnl_pct = ((current_price - entry_price) / entry_price) * 100
                strategy_pnl += pnl

                emoji = "üü¢" if pnl >= 0 else "üî¥"
                result += f"  {emoji} {ticker}: ‚Çπ{pnl:,.0f} ({pnl_pct:+.1f}%)\n"

            result += f"<b>  Subtotal: ‚Çπ{strategy_pnl:,.0f}</b>\n\n"
            grand_total_pnl += strategy_pnl

        result += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        pnl_emoji = "üü¢" if grand_total_pnl >= 0 else "üî¥"
        result += f"<b>{pnl_emoji} Total Unrealized P&L: ‚Çπ{grand_total_pnl:,.0f}</b>"

        return result
    except Exception as e:
        return f"‚ùå Error: {e}"

def handle_hold(ticker):
    """Mark position to hold (suppress alerts, wait for hard stop)"""
    try:
        # Check if position exists
        positions = get_active_positions()
        ticker_found = False
        for p in positions:
            if p['ticker'] == ticker:
                ticker_found = True
                break

        if not ticker_found:
            return f"‚ùå Position {ticker} not found"

        # Add to circuit breaker holds
        add_circuit_breaker_hold(ticker, 'SWING')  # Adjust strategy detection if needed

        return f"""‚úÖ <b>HOLD COMMAND RECEIVED</b>

üìä Ticker: {ticker}

Position will continue holding.
Alert suppressed for today.
Circuit breaker (5%) still active."""

    except Exception as e:
        return f"‚ùå Error: {e}"

def handle_exit(ticker):
    """Force exit position immediately"""
    try:
        # Find position
        positions = get_active_positions()
        position = None
        for p in positions:
            if p['ticker'] == ticker:
                position = p
                break

        if not position:
            return f"‚ùå Position {ticker} not found"

        entry_price = float(position['entry_price'])
        qty = int(position['quantity'])
        strategy = position['strategy']

        # Get current price
        current_price = entry_price
        if YFINANCE_AVAILABLE:
            try:
                stock = yf.Ticker(ticker)
                hist = stock.history(period='1d')
                if not hist.empty:
                    current_price = float(hist['Close'].iloc[-1])
            except:
                pass

        # Calculate P&L
        pnl = (current_price - entry_price) * qty
        pnl_pct = ((current_price - entry_price) / entry_price) * 100

        # Close position
        close_position(ticker, strategy, current_price, pnl)
        update_capital(strategy, pnl)

        # Log trade
        log_trade(
            ticker=ticker,
            strategy=strategy,
            signal='SELL',
            price=current_price,
            quantity=qty,
            pnl=pnl,
            notes='MANUAL-EXIT via Telegram'
        )

        return f"""‚úÖ <b>MANUAL EXIT EXECUTED</b>

üìä Ticker: {ticker}
üì• Entry: ‚Çπ{entry_price:.2f}
üì§ Exit: ‚Çπ{current_price:.2f}
üí∞ P&L: ‚Çπ{pnl:,.0f} ({pnl_pct:+.2f}%)
üì¶ Qty: {qty}

Position closed per your command."""

    except Exception as e:
        return f"‚ùå Error exiting position: {e}"

def handle_smart_stop(ticker):
    """Enable smart-stop mode (use ATR/Chandelier stops instead of circuit breaker)"""
    try:
        # Check if position exists
        positions = get_active_positions()
        ticker_found = False
        for p in positions:
            if p['ticker'] == ticker:
                ticker_found = True
                break

        if not ticker_found:
            return f"‚ùå Position {ticker} not found"

        # In PostgreSQL version, this is handled via circuit_breaker_holds table
        # We can add a special note or use a different mechanism
        # For now, use the hold mechanism with a note
        add_circuit_breaker_hold(ticker, 'SWING', hold_type='SMART_STOP')

        return f"""‚úÖ <b>SMART-STOP MODE ENABLED</b>

üìä Ticker: {ticker}

System will use ATR/Chandelier/Support stops.
Circuit breaker suppressed."""

    except Exception as e:
        return f"‚ùå Error: {e}"

def process_command(text):
    parts = text.strip().split()
    cmd = parts[0].lower()

    # Simple commands (no arguments)
    if cmd == '/help':
        return handle_help()
    elif cmd == '/status':
        return handle_status()
    elif cmd == '/positions':
        return handle_positions()
    elif cmd == '/pnl':
        return handle_pnl()
    elif cmd == '/daily':
        return handle_positions('DAILY')
    elif cmd == '/swing':
        return handle_positions('SWING')
    elif cmd == '/capital':
        return handle_capital()

    # Commands with ticker argument
    elif cmd == '/hold' and len(parts) == 2:
        ticker = parts[1].upper()
        return handle_hold(ticker)
    elif cmd == '/exit' and len(parts) == 2:
        ticker = parts[1].upper()
        return handle_exit(ticker)
    elif cmd == '/smart-stop' and len(parts) == 2:
        ticker = parts[1].upper()
        return handle_smart_stop(ticker)

    # Unknown or malformed command
    else:
        return "Unknown command or missing arguments. Try /help"

print("ü§ñ LightRain Telegram Bot Listener Starting...")
print(f"Time: {datetime.now().strftime('%d %b %Y, %H:%M:%S')}")
send_message("ü§ñ LightRain Bot online! Type /help for commands.")

offset = None
while True:
    try:
        updates = get_updates(offset)

        if updates.get('ok') and updates.get('result'):
            for update in updates['result']:
                offset = update['update_id'] + 1

                if 'message' in update and 'text' in update['message']:
                    text = update['message']['text']
                    user_id = str(update['message']['chat']['id'])

                    # Only respond to authorized user
                    if user_id == CHAT_ID:
                        print(f"Command received: {text}")
                        response = process_command(text)
                        send_message(response)

        time.sleep(1)

    except KeyboardInterrupt:
        print("\nüëã Bot stopping...")
        send_message("ü§ñ Bot going offline")
        break
    except Exception as e:
        print(f"Error: {e}")
        time.sleep(5)
